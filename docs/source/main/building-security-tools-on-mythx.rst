MythX API Developer Guide
=========================

This section of the guide is aimed at developers who want build security tools using the MythX API.

.. contents:: :local:


What Tools to Build?
--------------------

Using MythX API, you can build security tools that find bugs in smart contracts for Ethereum or compatible
blockchains such as Tron and Quorum. Currently, we support Solidity code and EVM bytecode, but we are working
on support for additional bytecode formats (e.g. eWASM) and languages. 

Some examples for potential MythX tools are:

- Plugins for dapp development environments, such as Truffle, Remix and Embark;
- Plugins for code editors (Sublime Text, Atom, vim,...);
- Apps and CI hooks for code repositories (Github, Gitlab);
- Command-line tools for security auditors;
- Integrations into dapp browsers and wallets;
- Standalone web interfaces.

Feel free however to experiment with the API in any way you want!


Revenue Sharing Program
-----------------------

We are planning to share 15% of all revenue received from paid API subscriptions back to tool developers. This
will apply from the day paid subscriptions go live, which will tentatively happen in May. Keep in mind though
that our project is still in an early stage and we can't guarantee the future success of MythX and/or Ethereum.

The amount revenue share you receive will depend on the number of daily active paying users of your tool. This
means that we have to keep track of usage statistic. Please make sure to pick a unique tool name and send
it in the `clientToolName field <https://api.mythx.io/v1/openapi#operation/submitAnalysis>`_ of
every API request.


API Specification
-----------------

Besides whatever you might find in this guide, the `MythX OpenAPI Spec <https://api.mythx.io/v1/openapi>`_
is the ultimate authority. Beyond that be dragons.


Language Bindings
-----------------

In most cases you'll want to use an existing client library that abstracts the low-level details of
interacting with MythX.

.. toctree::
    :maxdepth: 1

    ../SDK/armlet
    ../SDK/shard


API Walkthrough
---------------

The `MythX API curl scripts <https://github.com/rocky/mythx-api-curl>`_ demonstrate
interaction with MythX API at the most basic level. The scripts will show
you the HTTP requests that get sent as well with the JSON output returned as the result
of each request.

The process for analyzing a smart contract works as follows:

* Authenticate with Ethereum address and password to retrieve an access token;
* Submit a contract for analysis, creating a job run with a UUID;
* See the status of job using the UUID of a previously submitted analysis;
* Get the results of a previously finished analysis using the UUID.

Let's run through a basic example. Make sure that curl is installed and clone the
Github repository to get started:

.. code-block:: console

  $ git clone https://github.com/rocky/mythx-api-curl
  $ cd mythx-api-curl


Authenticating
~~~~~~~~~~~~~~

MythX uses `JSON Web Token (JWT) <https://jwt.io>`_ authentication. In this authentication scheme,
the user submits their username and password to the `login endpoint <https://api.mythx.io/v1/openapi#operation/login>`_.
Upon successful login the server returns the following:

- A timed access token. This token is needs to be sent by the client with every request to access the API.
- A refresh token that can be used to request a new access token once the current one times out.

To execute the login process on the shell, set the `MYTHX_PASSWORD` to and `MYTHX_ETH_ADDRESS` 
environment vairables to your Ethereum address and API password:

.. code-block:: console

  $ export MYTHX_PASSWORD=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  $ export MYTHX_ETH_ADDRESS=0x.............

Then run the login script as follows:

.. code-block:: console

   $ . ./login.sh
   Successfully logged into MythX

If authentication succeeds, the login script will set the `MYTHX_ACCESS_TOKEN` and `MYTHX_REFRESH_TOKEN`
environment variables.

.. code-block:: console

  $ echo $MYTHX_ACCESS_TOKEN
    eyJhb(...)m38eVH7P2TRjM
  $ echo $MYTHX_REFRESH_TOKEN
    eyJhd(...)Ni00ODg5LTRjM

With these variables set you can execute the remaining scripts. Test this by retrieving the API version:

.. code-block:: console

  $ ./api-version.sh 
  Issuing HTTP GET https://api.mythx.io/v1/version
  curl completed sucessfully. Output follows...
  HTTP/2 200 
  {
    "api": "v1.3.2",
    "maru": "0.3.2",
    "mythril": "0.20.0"
  }


Submitting an Analysis Job
~~~~~~~~~~~~~~~~~~~~~~~~~~

To launch a security analysis job the client needs to submit the Solidity source code 
and/or EVM bytecode via a POST request to the
`analyses endpoint <https://api.mythx.io/v1/openapi#operation/submitAnalysis>`_. The input
format is similar to the JSON output generated by solc and Truffle. Here is an example:

.. code-block:: json

  { 
     "clientToolName": "mythx-api-curl",
     "data":
     {
        "deployedBytecode" : "6080605482019055600192(...)",
        "deployedSourceMap" : "25:503:0:-;;;;6202:0;(...)",
        "sourceList" : [
           "token.sol"
        ],
        "bytecode" : "608060405234801561001(...)",
        "sourceMap" : "25:503:0:-;;;;8:9:-1(...)",
        "analysisMode" : "quick",
        "sources" : {
           "token.sol" : {
              "source" : "pragma solidity ^0.5.0;\n\ncontract Token {\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n\n  function transfer(address _to, uint _value) public returns (bool) {\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n"
           }
        },
        "contractName" : "Token"
     }


The input JSON contains the following fields:

- clientToolName: A name that uniquely identifies your MythX tool.
- data: A dictionary containing the data of the contract to be analyzed
- deployedBytecode: The runtime bytecode of the contract.
- deployedSourceMap: The source mapping generated by solc for the runtime bytecode.
- bytecode: The creation bytcode of the contract.
- sourceMap: The source mapping generated buy solc for the creation bytecode.
- analysisMode: The type of analysis ("quick" of "full").
- sourceList: A list of source files refered to by the source maps.
- sources: A dictionary containing the original source code of each code file.
- contractName: The name of the main contract class to be analyzed.

**Note that both source code and bytecode MUST be submitted to receive complete results.**

The `analysisMode` field is used to select the type of analysis. Currently two modes are supported:

- quick: Perform static analysis and shallow symbolic analysis and input fuzzing. Returns a result within 90 seconds.
- full: Perform static analysis and deep symbolic analysis and input fuzzing. May run for up to 2 hours.

If successful, the API returrns a UUID that can then be used to retrieve the status and results
of the analysis.

.. code-block:: console

  $ ./analyses.sh sample-json/PublicArray.js
  Issuing HTTP POST http://api.mythx.io/v1/analyses
    (with MYTHX_API_KEY and EVM bytecode)
  curl completed successfully. Output follows...
  HTTP/1.1 200 OK
  {
    "result": "Queued",
    "uuid": "bf9fe267-d322-4641-aae2-a89e62f40770"
  }


Polling the API to Obtain Job Status
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: console

  $ ./analyses-status.sh "bf9fe267-d322-4641-aae2-a89e62f40770"
  Issuing HTTP GET http://api.mythx.io/v1/analyses/bf9fe267-d322-4641-aae2-a89e62f40770
    (with MYTHX_API_KEY)
  curl completed successfully. Output follows...
  HTTP/1.1 200 OK
  {
    "result": "Finished",
    "uuid": "bf9fe267-d322-4641-aae2-a89e62f40770"
  }


Obtaining Analysis Results
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: console

  $ ./analyses-results.sh "bf9fe267-d322-4641-aae2-a89e62f40770"


API Details
-----------

Token Expiration Times
~~~~~~~~~~~~~~~~~~~~~~

Validity times for the Java Web Tokens are set as follows:

- Access tokens are valid for 10 minutes;
- Refresh tokens are valid for 4 weeks.


Rate Limits
~~~~~~~~~~~

API rate limits need to be considered when designing MythX tools as sending excessive requests may cause API errors. Currently the following rate limits apply:

- The client can submit up to **2 requests per second.**
- The API can queue up to **10 analysis jobs** per client. However, a maximum of **four workers** will be allocated to a single client. It is therefore recommended to limit the number of parallel analysis jobs to four.
- The client can perform up to **10,000 API requests within 24 hours.**


Compiler Settings
-----------------

It is recommended to activate optimization when compiling source code for analysis. This reduces the complexity of the bytecode, allowing for better performance in the fuzzing and symbolic analysis steps and increasing code coverage.

For example, when using `solcjs`, add the following to the compiler settings:

.. code-block:: javascript

    settings: {
        (...)
        optimizer: {
          enabled: true,
          runs: 200
        }
    }


Example Code
------------

`Sabre <https://github.com/b-mueller/sabre>`_ is a minimal MythX CLI written in JavaScript. 
It shows how to compile a Solidity file using solc-js and submit the compiler output
to MythX using the `armlet JavaScript library <https://github.com/ConsenSys/armlet>`_.


.. seealso::

  * `Sabre - Minimum Viable MythX Client <https://github.com/b-mueller/sabre>`_


