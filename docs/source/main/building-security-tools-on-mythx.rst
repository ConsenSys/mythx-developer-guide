MythX API Developer Guide
=========================

This section of the guide is aimed at developers who want build security tools using the MythX API.

.. contents:: :local:


API Specification
-----------------

Besides whatever you might find in this guide, the `MythX OpenAPI Spec <https://api.mythx.io/v1/openapi>`_
is the ultimate authority. Beyond that be dragons.


Language Bindings
-----------------

In most cases you'll want to use an existing client library that abstracts the low-level details of
interacting with MythX.

.. toctree::
    :maxdepth: 1

    ../SDK/armlet
    ../SDK/shard


Low-Level Walkthrough
---------------------

The `MythX API curl scripts <https://github.com/rocky/mythx-api-curl>`_ demonstrate
interaction with MythX API at the most basic level. The scripts will show
you the HTTP requests that get sent as well with the JSON output returned as the result
of each request.

The process for analyzing a smart contract works as follows:

* Authenticate with Ethereum address and password to retrieve an access token;
* Submit a contract for analysis, creating a job run with a UUID;
* See the status of job using the UUID of a previously submitted analysis;
* Get the results of a previously finished analysis using the UUID.

Let's run through a basic example. Make sure that curl is installed and clone the
Github repository to get started:

.. code-block:: console

  $ git clone https://github.com/rocky/mythx-api-curl
  $ cd mythx-api-curl


Authenticating
~~~~~~~~~~~~~~

MythX uses `JSON Web Token (JWT) <https://jwt.io>`_ authentication. In this authentication scheme,
the user submits their username and password to the `login endpoint <https://api.mythx.io/v1/openapi#operation/login>`_.
Upon successful login the server returns the following:

- A timed access token. This token is needs to be sent by the client with every request to access the API.
- A refresh token that can be used to request a new access token once the current one times out.

To execute the login process on the shell, set the `MYTHX_PASSWORD` to and `MYTHX_ETH_ADDRESS` 
environment vairables to your Ethereum address and API password:

.. code-block:: console

  $ export MYTHX_PASSWORD=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  $ export MYTHX_ETH_ADDRESS=0x.............

Then run the login script as follows:

.. code-block:: console

   $ . ./login.sh
   Successfully logged into MythX

If authentication succeeds, the login script will set the `MYTHX_ACCESS_TOKEN` and `MYTHX_REFRESH_TOKEN`
environment variables.

.. code-block:: console

  $ echo $MYTHX_ACCESS_TOKEN
    eyJhb(...)m38eVH7P2TRjM
  $ echo $MYTHX_REFRESH_TOKEN
    eyJhd(...)Ni00ODg5LTRjM

With these variables set you can execute the remaining scripts. Test this by retrieving the API version:

.. code-block:: console

  $ ./api-version.sh 
  Issuing HTTP GET https://api.mythx.io/v1/version
  curl completed sucessfully. Output follows...
  HTTP/2 200 
  {
    "api": "v1.3.2",
    "maru": "0.3.2",
    "mythril": "0.20.0"
  }


Submitting an Analysis Job
~~~~~~~~~~~~~~~~~~~~~~~~~~

To launch a security analysis job the client needs to submit the Solidity source code 
and/or EVM bytecode via a POST request to the
`analyses endpoint <https://api.mythx.io/v1/openapi#operation/submitAnalysis>`_. The input
format is similar to the JSON output generated by solc and Truffle and contains the following fields:

- contractName: The name of the main contract class being analyzed.
- bytecode: The creation bytcode of the contract.
- sourceMap: The source mapping generated buy solc for the creation bytecode,.
- deployedBytecode: The runtime bytecode of the contract.
- deployedSourceMap: The source mapping generated by solc for the runtime bytecode.
- sourceList: A list of source files refered to by the source maps.
- sources: A dictionary containing the original source code of each code file.

**Note that both source code and bytecode MUST be submitted to receive complete results.**

The `analysisMode` field is used to select the type of analysis. Currently two modes are supported:

- quick: Perform static analysis and shallow symbolic analysis and input fuzzing. Returns a result within 90 seconds.
- full: Perform static analysis and deep symbolic analysis and input fuzzing. May run for up to 2 hours.

If successful, the API returrns a UUID that can then be used to retrieve the status and results
of the analysis.

.. code-block:: console

  $ ./analyses.sh sample-json/PublicArray.js
  Issuing HTTP POST http://api.mythx.io/v1/analyses
    (with MYTHX_API_KEY and EVM bytecode)
  curl completed successfully. Output follows...
  HTTP/1.1 200 OK
  {
    "result": "Queued",
    "uuid": "bf9fe267-d322-4641-aae2-a89e62f40770"
  }


Polling the API to Obtain Job Status
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: console

  $ ./analyses-status.sh "bf9fe267-d322-4641-aae2-a89e62f40770"
  Issuing HTTP GET http://api.mythx.io/v1/analyses/bf9fe267-d322-4641-aae2-a89e62f40770
    (with MYTHX_API_KEY)
  curl completed successfully. Output follows...
  HTTP/1.1 200 OK
  {
    "result": "Finished",
    "uuid": "bf9fe267-d322-4641-aae2-a89e62f40770"
  }


Obtaining Analysis Results
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: console

  $ ./analyses-results.sh "bf9fe267-d322-4641-aae2-a89e62f40770"




Rate Limits
-----------

API rate limits need to be considered when designing MythX tools as sending excessive requests may cause API errors. Currently the following rate limits apply:

- The client can submit up to **2 requests per second.**
- The API can queue up to **10 analysis jobs** per client. However, a maximum of **four workers** will be allocated to a single client. It is therefore recommended to limit the number of parallel analysis jobs to four.
- The client can perform up to **10,000 API requests within 24 hours.**


Compiler Settings
-----------------

It is recommended to activate optimization when compiling source code for analysis. This reduces the complexity of the bytecode, allowing for better performance in the fuzzing and symbolic analysis steps and increasing code coverage.

For example, when using `solcjs`, add the following to the compiler settings:

.. code-block:: javascript

    settings: {
        (...)
        optimizer: {
          enabled: true,
          runs: 200
        }
    }


Example Code
------------

`Sabre <https://github.com/b-mueller/sabre>`_ is a minimal MythX CLI written in JavaScript. 
It shows how to compile a Solidity file using solc-js and submit the compiler output
to MythX using the `armlet JavaScript library <https://github.com/ConsenSys/armlet>`_.



.. seealso::

  * `Sabre - Minimum Viable MythX Client <https://github.com/b-mueller/sabre>`_


